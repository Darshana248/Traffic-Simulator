function e(e,t){if(!1===e||null==e)throw console.warn("Test invariant failed:",t),new Error(t)}class t{nodes=new Set;edges=new Map;edgeWeights=new Map;edgeProperties=new Map;addNode(e){return this.nodes.has(e)||this.nodes.add(e),this.edges.has(e)||this.edges.set(e,new Set),this}removeNode(e){this.edges.delete(e),this.nodes.delete(e);for(const t of this.edges.values())t.delete(e);return this}adjacent(e){return this.edges.get(e)}setEdgeWeight(t,r,o){this.edgeWeights.has(t)||this.edgeWeights.set(t,new Map);const n=this.edgeWeights.get(t);return e(n),n.set(r,o),this}getEdgeWeight(e,t){return this.edgeWeights.get(e)?.get(t)??1}setEdgeProperties(t,r,o){this.edgeProperties.has(t)||this.edgeProperties.set(t,new Map);const n=this.edgeProperties.get(t);return e(n),n.set(r,o),this}getEdgeProperties(e,t){return this.edgeProperties.get(e)?.get(t)}addEdge(t,r,...o){let n,s;const d=o[0];"number"==typeof d&&(n=d),"object"==typeof d&&(n=d.weight,d&&(s=Object.prototype.hasOwnProperty.call(d,"props")?d.props:void 0)),this.addNode(t),this.addNode(r);const i=this.adjacent(t);return e(i),i.add(r),void 0!==n&&this.setEdgeWeight(t,r,n),void 0!==s&&this.setEdgeProperties(t,r,s),this}removeEdge(e,t){return this.edges.get(e)?.delete(t),this.edgeProperties.get(e)?.delete(t),this}hasEdge(e,t){return this.edges.get(e)?.has(t)??!1}}class r extends Error{constructor(e){super(e),Object.setPrototypeOf(this,r.prototype)}}function o(e,t,n,s,d,i){const{errorOnCycle:g=!1,shouldFollow:h}=i;if(s.has(d)&&g)throw new r("Cycle found");n.has(d)||(n.add(d),s.add(d),e.adjacent(d)?.forEach((r=>{(void 0===h||h({source:d,target:r,graph:e,props:e.getEdgeProperties(d,r)}))&&o(e,t,n,s,r,i)})),s.delete(d),t.push(d))}function n(e,t={}){const{sourceNodes:r=Array.from(e.nodes),includeSourceNodes:n=!0}=t,s=new Set,d=new Set,i=[];if(n){for(let n=0;n<r.length;n++){const g=r[n];g&&o(e,i,s,d,g,t)}return i}for(let e=0;e<r.length;e++){const t=r[e];t&&s.add(t)}for(let n=0;n<r.length;n++){const g=r[n];g&&e.adjacent(g)?.forEach((r=>o(e,i,s,d,r,t)))}return i}function s(e){let t,r=1/0;const{d:o,q:n}=e;return n.forEach((e=>{const n=o.get(e)??1/0;n<r&&(r=n,t=e)})),void 0===t?(n.clear(),null):(n.delete(t),t)}function d(t,r,o,n){const{d:s,p:d}=r,i=t.getEdgeWeight(o,n),g=s.get(o),h=s.get(n);e(g,"Missing source distance"),e(h,"Missing target distance"),h>g+i&&(s.set(n,g+i),d.set(n,o))}function i(e,t,r,o){const n=e.nodes,{q:i}=t;for(!function(e,{d:t},r,o){if(e.forEach((e=>{t.set(e,1/0)})),t.get(r)!==1/0)throw new Error("Source node is not in the graph");if(t.get(o)!==1/0)throw new Error("Destination node is not in the graph");t.set(r,0)}(n,t,r,o),function(e,{q:t}){e.forEach((e=>{t.add(e)}))}(n,t);0!==i.size;){const r=s(t);if(null===r)return;e.adjacent(r)?.forEach((o=>{d(e,t,r,o)}))}}function g(e,t,r){const o={d:new Map,p:new Map,q:new Set};return i(e,o,t,r),function(e,t,r,o){const{p:n}=t,s=[];let d=0,i=o;for(;n.has(i);){const t=n.get(i);s.push(i),d+=e.getEdgeWeight(t,i),i=t}if(i!==r)throw new Error("No path found");return s.push(i),s.reverse(),{nodes:s,weight:d}}(e,o,t,r)}function h(e,t,r){let o=g(e,t,r);const n=[o],s=o.weight,d=[];for(;o.weight;){const i=o.nodes[0],h=o.nodes[1];e.hasEdge(i,h)&&(d.push({u:i,v:h,weight:e.getEdgeWeight(i,h),props:e.getEdgeProperties(i,h)}),e.removeEdge(i,h)),e.hasEdge(h,i)&&(d.push({u:h,v:i,weight:e.getEdgeWeight(h,i),props:e.getEdgeProperties(h,i)}),e.removeEdge(h,i));try{if(o=g(e,t,r),!o.weight||s<o.weight)break;n.push(o)}catch(e){break}}for(const{u:t,v:r,weight:o,props:n}of d)e.addEdge(t,r,o,n);return n}function c(e,t={}){return n(e,{...t,errorOnCycle:!0}).reverse()}function a(e,t,r){const o=[],n=[];return u(e,o,n,new Set,t,r)&&f(e,o,n,new Set,r),n}function u(e,t,r,o,n,s){return!!o.has(n)||(o.add(n),t.push(n),n==s?(r.push(n),!1):Array.from(e.adjacent(n)??[]).every((n=>u(e,t,r,o,n,s))))}function f(e,t,r,o,n){o.has(n)||(o.add(n),t.indexOf(n)>=0?r.push(n):0==r.length&&e.adjacent(n)?.forEach((n=>{f(e,t,r,o,n)})))}function p(e,t){let r=0;for(const o of e.edges.values())for(let e of o)e===t&&r++;return r}function l(e,t){return e.edges.get(t)?.size??0}function E(e){const r=new t;for(let[t,o]of e.edges.entries())o.forEach((o=>{r.addEdge.apply(r,[t,o]);const n=e.edgeWeights.get(t)?.get(o);n&&r.setEdgeWeight(t,o,n);const s=e.getEdgeProperties(t,o);s&&r.setEdgeProperties(t,o,s)}));return r}function w(e,t){try{return n(e,{...t,includeSourceNodes:!0,errorOnCycle:!0}),!1}catch(e){if(e instanceof r)return!0;throw e}}function v(e,t={}){const{includeDefaultWeight:r=!1}=t,o={nodes:Array.from(e.nodes),links:[]};return o.nodes.forEach((t=>{const n=t;e.adjacent(n)?.forEach((t=>{const s=e.getEdgeWeight(n,t),d=e.getEdgeProperties(n,t),i={source:n,target:t};(1!=s||r)&&(i.weight=s),d&&(i.props=d),o.links.push(i)}))})),o}function y(...e){const[r,o]=e,n=new t,s=new Map;return r.nodes.forEach((e=>{n.addNode(e),o&&s.set(o(e),e)})),r.links.forEach((e=>{if(!o)return void n.addEdge.apply(n,[e.source,e.target,e.weight,e.props]);const t=s.get(o(e.source))??e.source,r=s.get(o(e.target))??e.target;n.addEdge.apply(n,[t,r,e.weight,e.props])})),n}function P(e,t){const r=[];return e.nodes.forEach((e=>{t(e)&&r.push(e)})),r}function W(e,t){const r=[];for(const o of e.nodes)t(o)&&r.push(o);if(0===r.length)throw new Error("Node not found.");if(r.length>1)throw new Error("More than one node found.");return r[0]}function j(e,t){for(const r of e.nodes)if(t(r))return r;throw new Error("Node not found.")}export{r as CycleError,t as Graph,E as cloneGraph,n as depthFirstSearch,y as deserializeGraph,P as findNodes,j as getFirstNode,W as getNode,w as hasCycle,p as indegree,a as lowestCommonAncestors,l as outdegree,v as serializeGraph,g as shortestPath,h as shortestPaths,c as topologicalSort};
